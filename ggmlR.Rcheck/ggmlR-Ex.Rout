
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ggmlR"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "ggmlR-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('ggmlR')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("GGML_SORT_ORDER_ASC")
> ### * GGML_SORT_ORDER_ASC
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: GGML_SORT_ORDER_ASC
> ### Title: Sort Order Constants
> ### Aliases: GGML_SORT_ORDER_ASC GGML_SORT_ORDER_DESC
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D GGML_SORT_ORDER_ASC   # 0 - Ascending order
> ##D GGML_SORT_ORDER_DESC  # 1 - Descending order
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("GGML_SORT_ORDER_ASC", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("GGML_TYPE_F32")
> ### * GGML_TYPE_F32
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: GGML_TYPE_F32
> ### Title: GGML Data Types
> ### Aliases: GGML_TYPE_F32 GGML_TYPE_F16 GGML_TYPE_Q4_0 GGML_TYPE_Q4_1
> ###   GGML_TYPE_Q8_0 GGML_TYPE_I32
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D GGML_TYPE_F32
> ##D GGML_TYPE_F16
> ##D GGML_TYPE_I32
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("GGML_TYPE_F32", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_add")
> ### * ggml_add
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_add
> ### Title: Add tensors
> ### Aliases: ggml_add
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D ggml_set_f32(b, c(5, 4, 3, 2, 1))
> ##D result <- ggml_add(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D ggml_set_f32(b, c(5, 4, 3, 2, 1))
> ##D result <- ggml_add(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_add", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_add1")
> ### * ggml_add1
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_add1
> ### Title: Add Scalar to Tensor (Graph)
> ### Aliases: ggml_add1
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D scalar <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 1)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D ggml_set_f32(scalar, 10)
> ##D result <- ggml_add1(ctx, a, scalar)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_add1", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_argsort")
> ### * ggml_argsort
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_argsort
> ### Title: Argsort - Get Sorting Indices (Graph)
> ### Aliases: ggml_argsort
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D # Create tensor with values to sort
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(3, 1, 4, 1, 5))
> ##D # Get indices for ascending sort
> ##D indices <- ggml_argsort(ctx, a, GGML_SORT_ORDER_ASC)
> ##D graph <- ggml_build_forward_expand(ctx, indices)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_i32(indices)
> ##D # result: [1, 3, 0, 2, 4] (0-indexed positions for sorted order)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_argsort", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_backend_sched_free")
> ### * ggml_backend_sched_free
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_backend_sched_free
> ### Title: Free backend scheduler
> ### Aliases: ggml_backend_sched_free
> 
> ### ** Examples
> 
> ## Not run: 
> ##D sched <- ggml_backend_sched_new(list(gpu_backend))
> ##D ggml_backend_sched_free(sched)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_backend_sched_free", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_backend_sched_graph_compute")
> ### * ggml_backend_sched_graph_compute
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_backend_sched_graph_compute
> ### Title: Compute graph using scheduler
> ### Aliases: ggml_backend_sched_graph_compute
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Multi-GPU example
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() >= 2) {
> ##D   gpu1 <- ggml_vulkan_init(0)
> ##D   gpu2 <- ggml_vulkan_init(1)
> ##D   sched <- ggml_backend_sched_new(list(gpu1, gpu2))
> ##D 
> ##D   ctx <- ggml_init(64 * 1024 * 1024)
> ##D   a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10000)
> ##D   b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10000)
> ##D   ggml_set_f32(a, rnorm(10000))
> ##D   ggml_set_f32(b, rnorm(10000))
> ##D 
> ##D   c <- ggml_add(ctx, a, b)
> ##D   graph <- ggml_build_forward_expand(ctx, c)
> ##D 
> ##D   # Reserve memory
> ##D   ggml_backend_sched_reserve(sched, graph)
> ##D 
> ##D   # Compute using both GPUs
> ##D   ggml_backend_sched_graph_compute(sched, graph)
> ##D 
> ##D   result <- ggml_get_f32(c)
> ##D 
> ##D   cat("Splits:", ggml_backend_sched_get_n_splits(sched), "\n")
> ##D   cat("Copies:", ggml_backend_sched_get_n_copies(sched), "\n")
> ##D 
> ##D   ggml_free(ctx)
> ##D   ggml_backend_sched_free(sched)
> ##D   ggml_vulkan_free(gpu1)
> ##D   ggml_vulkan_free(gpu2)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_backend_sched_graph_compute", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_backend_sched_new")
> ### * ggml_backend_sched_new
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_backend_sched_new
> ### Title: Create a new backend scheduler
> ### Aliases: ggml_backend_sched_new
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() >= 2) {
> ##D   # Create two GPU backends (CPU is added automatically)
> ##D   gpu1 <- ggml_vulkan_init(0)
> ##D   gpu2 <- ggml_vulkan_init(1)
> ##D 
> ##D   # Create scheduler with both GPUs + CPU (automatic)
> ##D   sched <- ggml_backend_sched_new(list(gpu1, gpu2), parallel = TRUE)
> ##D 
> ##D   # The scheduler now has 3 backends: GPU1, GPU2, CPU
> ##D   cat("Backends:", ggml_backend_sched_get_n_backends(sched), "\\n")
> ##D 
> ##D   # Use scheduler...
> ##D 
> ##D   # Cleanup
> ##D   ggml_backend_sched_free(sched)
> ##D   ggml_vulkan_free(gpu1)
> ##D   ggml_vulkan_free(gpu2)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_backend_sched_new", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_backend_sched_reserve")
> ### * ggml_backend_sched_reserve
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_backend_sched_reserve
> ### Title: Reserve memory for scheduler
> ### Aliases: ggml_backend_sched_reserve
> 
> ### ** Examples
> 
> ## Not run: 
> ##D sched <- ggml_backend_sched_new(list(gpu_backend))
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 1000)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 1000)
> ##D c <- ggml_add(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, c)
> ##D 
> ##D # Reserve memory based on this graph
> ##D ggml_backend_sched_reserve(sched, graph)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_backend_sched_reserve", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_build_forward_expand")
> ### * ggml_build_forward_expand
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_build_forward_expand
> ### Title: Build forward expand
> ### Aliases: ggml_build_forward_expand
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D ggml_set_f32(b, c(5, 4, 3, 2, 1))
> ##D result <- ggml_add(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_set_f32(a, 1:10)
> ##D ggml_set_f32(b, 11:20)
> ##D c <- ggml_add(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, c)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(c)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_build_forward_expand", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_concat")
> ### * ggml_concat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_concat
> ### Title: Concatenate Tensors (Graph)
> ### Aliases: ggml_concat
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 4, 3)
> ##D b <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 4, 2)
> ##D ggml_set_f32(a, rnorm(12))
> ##D ggml_set_f32(b, rnorm(8))
> ##D # Concatenate along dimension 1: result is 4x5
> ##D c <- ggml_concat(ctx, a, b, 1)
> ##D graph <- ggml_build_forward_expand(ctx, c)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_concat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_cpu_add")
> ### * ggml_cpu_add
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_cpu_add
> ### Title: Element-wise Addition (CPU Direct)
> ### Aliases: ggml_cpu_add
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D ggml_set_f32(b, c(5, 4, 3, 2, 1))
> ##D ggml_cpu_add(a, b)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_cpu_add", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_cpu_mul")
> ### * ggml_cpu_mul
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_cpu_mul
> ### Title: Element-wise Multiplication (CPU Direct)
> ### Aliases: ggml_cpu_mul
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D ggml_set_f32(b, c(2, 2, 2, 2, 2))
> ##D ggml_cpu_mul(a, b)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_cpu_mul", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_cpy")
> ### * ggml_cpy
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_cpy
> ### Title: Copy Tensor with Type Conversion (Graph)
> ### Aliases: ggml_cpy
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D # Create F32 tensor
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 100)
> ##D ggml_set_f32(a, rnorm(100))
> ##D # Create F16 tensor for output
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F16, 100)
> ##D # Copy with F32 -> F16 conversion
> ##D result <- ggml_cpy(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_cpy", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_cycles")
> ### * ggml_cycles
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_cycles
> ### Title: Get CPU Cycles
> ### Aliases: ggml_cycles
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_cycles()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_cycles", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_cycles_per_ms")
> ### * ggml_cycles_per_ms
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_cycles_per_ms
> ### Title: Get CPU Cycles per Millisecond
> ### Aliases: ggml_cycles_per_ms
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_cycles_per_ms()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_cycles_per_ms", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_diag")
> ### * ggml_diag
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_diag
> ### Title: Diagonal Matrix (Graph)
> ### Aliases: ggml_diag
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 3)
> ##D ggml_set_f32(a, c(1, 2, 3))
> ##D d <- ggml_diag(ctx, a)  # 3x3 diagonal matrix
> ##D graph <- ggml_build_forward_expand(ctx, d)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_diag", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_diag_mask_inf")
> ### * ggml_diag_mask_inf
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_diag_mask_inf
> ### Title: Diagonal Mask with -Inf (Graph)
> ### Aliases: ggml_diag_mask_inf
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D # Create attention scores matrix
> ##D scores <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 4, 4)
> ##D ggml_set_f32(scores, rep(1, 16))
> ##D # Apply causal mask
> ##D masked <- ggml_diag_mask_inf(ctx, scores, 0)
> ##D graph <- ggml_build_forward_expand(ctx, masked)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_diag_mask_inf", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_div")
> ### * ggml_div
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_div
> ### Title: Element-wise Division (Graph)
> ### Aliases: ggml_div
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(10, 20, 30, 40, 50))
> ##D ggml_set_f32(b, c(2, 2, 2, 2, 2))
> ##D result <- ggml_div(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_div", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_dup")
> ### * ggml_dup
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_dup
> ### Title: Duplicate Tensor (Graph)
> ### Aliases: ggml_dup
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D b <- ggml_dup(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, b)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(b)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_dup", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_dup_tensor")
> ### * ggml_dup_tensor
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_dup_tensor
> ### Title: Duplicate Tensor
> ### Aliases: ggml_dup_tensor
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 100)
> ##D b <- ggml_dup_tensor(ctx, a)
> ##D ggml_nelements(b)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_dup_tensor", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_elu")
> ### * ggml_elu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_elu
> ### Title: ELU Activation (Graph)
> ### Aliases: ggml_elu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D r <- ggml_elu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_elu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_estimate_memory")
> ### * ggml_estimate_memory
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_estimate_memory
> ### Title: Estimate Required Memory
> ### Aliases: ggml_estimate_memory
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # For 1000x1000 F32 matrix
> ##D ggml_estimate_memory(GGML_TYPE_F32, 1000, 1000)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_estimate_memory", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_flash_attn_ext")
> ### * ggml_flash_attn_ext
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_flash_attn_ext
> ### Title: Flash Attention (Graph)
> ### Aliases: ggml_flash_attn_ext
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(64 * 1024 * 1024)
> ##D head_dim <- 64
> ##D n_head <- 8
> ##D n_head_kv <- 2  # GQA with 4:1 ratio
> ##D seq_len <- 32
> ##D q <- ggml_new_tensor_4d(ctx, GGML_TYPE_F32, head_dim, n_head, seq_len, 1)
> ##D k <- ggml_new_tensor_4d(ctx, GGML_TYPE_F32, head_dim, n_head_kv, seq_len, 1)
> ##D v <- ggml_new_tensor_4d(ctx, GGML_TYPE_F32, head_dim, n_head_kv, seq_len, 1)
> ##D ggml_set_f32(q, rnorm(head_dim * n_head * seq_len))
> ##D ggml_set_f32(k, rnorm(head_dim * n_head_kv * seq_len))
> ##D ggml_set_f32(v, rnorm(head_dim * n_head_kv * seq_len))
> ##D # Scale = 1/sqrt(head_dim)
> ##D scale <- 1.0 / sqrt(head_dim)
> ##D # Compute attention
> ##D out <- ggml_flash_attn_ext(ctx, q, k, v, NULL, scale, 0.0, 0.0)
> ##D graph <- ggml_build_forward_expand(ctx, out)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_flash_attn_ext", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_free")
> ### * ggml_free
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_free
> ### Title: Free GGML context
> ### Aliases: ggml_free
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_free", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_gallocr_alloc_graph")
> ### * ggml_gallocr_alloc_graph
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_gallocr_alloc_graph
> ### Title: Allocate Memory for Graph
> ### Aliases: ggml_gallocr_alloc_graph
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D galloc <- ggml_gallocr_new()
> ##D 
> ##D # Create graph
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D b <- ggml_relu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, b)
> ##D 
> ##D # Allocate and compute
> ##D ggml_gallocr_alloc_graph(galloc, graph)
> ##D ggml_graph_compute(ctx, graph)
> ##D 
> ##D ggml_gallocr_free(galloc)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_gallocr_alloc_graph", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_gallocr_new")
> ### * ggml_gallocr_new
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_gallocr_new
> ### Title: Create Graph Allocator
> ### Aliases: ggml_gallocr_new
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D galloc <- ggml_gallocr_new()
> ##D 
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D b <- ggml_relu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, b)
> ##D 
> ##D # Allocate graph
> ##D ggml_gallocr_alloc_graph(galloc, graph)
> ##D 
> ##D ggml_gallocr_free(galloc)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_gallocr_new", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_geglu")
> ### * ggml_geglu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_geglu
> ### Title: GeGLU (GELU Gated Linear Unit) (Graph)
> ### Aliases: ggml_geglu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 8, 3)
> ##D ggml_set_f32(a, rnorm(24))
> ##D r <- ggml_geglu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)  # Shape: 4x3
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_geglu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_gelu")
> ### * ggml_gelu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_gelu
> ### Title: GELU Activation (Graph)
> ### Aliases: ggml_gelu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D result <- ggml_gelu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_gelu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_gelu_erf")
> ### * ggml_gelu_erf
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_gelu_erf
> ### Title: Exact GELU Activation (Graph)
> ### Aliases: ggml_gelu_erf
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D r <- ggml_gelu_erf(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_gelu_erf", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_get_f32")
> ### * ggml_get_f32
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_get_f32
> ### Title: Get F32 data
> ### Aliases: ggml_get_f32
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D tensor <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(tensor, c(1, 2, 3, 4, 5))
> ##D ggml_get_f32(tensor)
> ##D ggml_free(ctx)
> ## End(Not run)
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(t, c(1, 2, 3, 4, 5))
> ##D ggml_get_f32(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_get_f32", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_get_i32")
> ### * ggml_get_i32
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_get_i32
> ### Title: Get I32 Data
> ### Aliases: ggml_get_i32
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D pos <- ggml_new_tensor_1d(ctx, GGML_TYPE_I32, 10)
> ##D ggml_set_i32(pos, 0:9)
> ##D ggml_get_i32(pos)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_get_i32", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_get_max_tensor_size")
> ### * ggml_get_max_tensor_size
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_get_max_tensor_size
> ### Title: Get Maximum Tensor Size
> ### Aliases: ggml_get_max_tensor_size
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D ggml_get_max_tensor_size(ctx)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_get_max_tensor_size", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_get_mem_size")
> ### * ggml_get_mem_size
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_get_mem_size
> ### Title: Get Context Memory Size
> ### Aliases: ggml_get_mem_size
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D ggml_get_mem_size(ctx)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_get_mem_size", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_get_n_threads")
> ### * ggml_get_n_threads
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_get_n_threads
> ### Title: Get Number of Threads
> ### Aliases: ggml_get_n_threads
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_get_n_threads()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_get_n_threads", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_get_no_alloc")
> ### * ggml_get_no_alloc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_get_no_alloc
> ### Title: Get No Allocation Mode
> ### Aliases: ggml_get_no_alloc
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D ggml_get_no_alloc(ctx)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_get_no_alloc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_get_rows")
> ### * ggml_get_rows
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_get_rows
> ### Title: Get Rows by Indices (Graph)
> ### Aliases: ggml_get_rows
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D # Create embedding matrix: 10 tokens, 4-dim embeddings
> ##D embeddings <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 4, 10)
> ##D ggml_set_f32(embeddings, rnorm(40))
> ##D # Token indices to look up
> ##D indices <- ggml_new_tensor_1d(ctx, GGML_TYPE_I32, 3)
> ##D ggml_set_i32(indices, c(0L, 5L, 2L))
> ##D # Get embeddings for tokens 0, 5, 2
> ##D result <- ggml_get_rows(ctx, embeddings, indices)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_get_rows", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_glu")
> ### * ggml_glu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_glu
> ### Title: Generic GLU (Gated Linear Unit) (Graph)
> ### Aliases: ggml_glu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D # Create tensor with 10 columns (will be split into 5 + 5)
> ##D a <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 4)
> ##D ggml_set_f32(a, rnorm(40))
> ##D # Apply SwiGLU
> ##D r <- ggml_glu(ctx, a, GGML_GLU_OP_SWIGLU, FALSE)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)  # Shape: 5x4
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_glu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_graph_compute")
> ### * ggml_graph_compute
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_graph_compute
> ### Title: Compute graph
> ### Aliases: ggml_graph_compute
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D result <- ggml_relu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_set_f32(a, 1:10)
> ##D ggml_set_f32(b, 11:20)
> ##D c <- ggml_add(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, c)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(c)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_graph_compute", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_graph_compute_with_ctx")
> ### * ggml_graph_compute_with_ctx
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_graph_compute_with_ctx
> ### Title: Compute Graph with Context (Alternative Method)
> ### Aliases: ggml_graph_compute_with_ctx
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_set_f32(a, 1:10)
> ##D c <- ggml_relu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, c)
> ##D ggml_graph_compute_with_ctx(ctx, graph)
> ##D result <- ggml_get_f32(c)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_graph_compute_with_ctx", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_graph_dump_dot")
> ### * ggml_graph_dump_dot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_graph_dump_dot
> ### Title: Export Graph to DOT Format
> ### Aliases: ggml_graph_dump_dot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D b <- ggml_relu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, b)
> ##D ggml_graph_dump_dot(graph, NULL, tempfile(fileext = ".dot"))
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_graph_dump_dot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_graph_node")
> ### * ggml_graph_node
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_graph_node
> ### Title: Get Graph Node
> ### Aliases: ggml_graph_node
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D b <- ggml_add(ctx, a, a)
> ##D graph <- ggml_build_forward_expand(ctx, b)
> ##D # Get the last node (output)
> ##D output <- ggml_graph_node(graph, -1)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_graph_node", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_hardsigmoid")
> ### * ggml_hardsigmoid
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_hardsigmoid
> ### Title: Hard Sigmoid Activation (Graph)
> ### Aliases: ggml_hardsigmoid
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-4, -1, 0, 1, 4))
> ##D r <- ggml_hardsigmoid(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)  # [0, 0.333, 0.5, 0.667, 1]
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_hardsigmoid", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_hardswish")
> ### * ggml_hardswish
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_hardswish
> ### Title: Hard Swish Activation (Graph)
> ### Aliases: ggml_hardswish
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-4, -1, 0, 1, 4))
> ##D r <- ggml_hardswish(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_hardswish", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_init")
> ### * ggml_init
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_init
> ### Title: Initialize GGML context
> ### Aliases: ggml_init
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_init", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_init_auto")
> ### * ggml_init_auto
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_init_auto
> ### Title: Create Context with Auto-sizing
> ### Aliases: ggml_init_auto
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # For two 1000x1000 matrices
> ##D ctx <- ggml_init_auto(mat1 = c(1000, 1000), mat2 = c(1000, 1000))
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_init_auto", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_is_available")
> ### * ggml_is_available
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_is_available
> ### Title: Check if GGML is available
> ### Aliases: ggml_is_available
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_is_available()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_is_available", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_is_contiguous")
> ### * ggml_is_contiguous
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_is_contiguous
> ### Title: Check if Tensor is Contiguous
> ### Aliases: ggml_is_contiguous
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_is_contiguous(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_is_contiguous", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_is_permuted")
> ### * ggml_is_permuted
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_is_permuted
> ### Title: Check if Tensor is Permuted
> ### Aliases: ggml_is_permuted
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 20)
> ##D ggml_is_permuted(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_is_permuted", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_is_transposed")
> ### * ggml_is_transposed
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_is_transposed
> ### Title: Check if Tensor is Transposed
> ### Aliases: ggml_is_transposed
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 20)
> ##D ggml_is_transposed(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_is_transposed", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_leaky_relu")
> ### * ggml_leaky_relu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_leaky_relu
> ### Title: Leaky ReLU Activation (Graph)
> ### Aliases: ggml_leaky_relu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D r <- ggml_leaky_relu(ctx, a, negative_slope = 0.1)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)  # [-0.2, -0.1, 0, 1, 2]
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_leaky_relu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_mul")
> ### * ggml_mul
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_mul
> ### Title: Multiply tensors
> ### Aliases: ggml_mul
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D ggml_set_f32(b, c(2, 2, 2, 2, 2))
> ##D result <- ggml_mul(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(1, 2, 3, 4, 5))
> ##D ggml_set_f32(b, c(2, 2, 2, 2, 2))
> ##D result <- ggml_mul(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_mul", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_mul_mat")
> ### * ggml_mul_mat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_mul_mat
> ### Title: Matrix Multiplication (Graph)
> ### Aliases: ggml_mul_mat
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D A <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 4, 3)
> ##D B <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 4, 2)
> ##D ggml_set_f32(A, 1:12)
> ##D ggml_set_f32(B, 1:8)
> ##D C <- ggml_mul_mat(ctx, A, B)
> ##D graph <- ggml_build_forward_expand(ctx, C)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(C)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_mul_mat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_mul_mat_id")
> ### * ggml_mul_mat_id
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_mul_mat_id
> ### Title: Matrix Multiplication with Expert Selection (Graph)
> ### Aliases: ggml_mul_mat_id
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(64 * 1024 * 1024)
> ##D # 4 experts, each with 8x16 weights (small for example)
> ##D experts <- ggml_new_tensor_3d(ctx, GGML_TYPE_F32, 8, 16, 4)
> ##D ggml_set_f32(experts, rnorm(8 * 16 * 4))
> ##D input <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 8, 2)
> ##D ggml_set_f32(input, rnorm(16))
> ##D # Select expert 0 for token 0, expert 2 for token 1
> ##D ids <- ggml_new_tensor_1d(ctx, GGML_TYPE_I32, 2)
> ##D ggml_set_i32(ids, c(0L, 2L))
> ##D output <- ggml_mul_mat_id(ctx, experts, input, ids)
> ##D graph <- ggml_build_forward_expand(ctx, output)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_mul_mat_id", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_n_dims")
> ### * ggml_n_dims
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_n_dims
> ### Title: Get Number of Dimensions
> ### Aliases: ggml_n_dims
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 20)
> ##D ggml_n_dims(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_n_dims", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_nbytes")
> ### * ggml_nbytes
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_nbytes
> ### Title: Get number of bytes
> ### Aliases: ggml_nbytes
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D tensor <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_nbytes(tensor)
> ##D ggml_free(ctx)
> ## End(Not run)
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_nbytes(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_nbytes", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_nelements")
> ### * ggml_nelements
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_nelements
> ### Title: Get number of elements
> ### Aliases: ggml_nelements
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D tensor <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 20)
> ##D ggml_nelements(tensor)
> ##D ggml_free(ctx)
> ## End(Not run)
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 20)
> ##D ggml_nelements(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_nelements", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_new_f32")
> ### * ggml_new_f32
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_new_f32
> ### Title: Create Scalar F32 Tensor
> ### Aliases: ggml_new_f32
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D scalar <- ggml_new_f32(ctx, 3.14)
> ##D ggml_get_f32(scalar)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_new_f32", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_new_i32")
> ### * ggml_new_i32
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_new_i32
> ### Title: Create Scalar I32 Tensor
> ### Aliases: ggml_new_i32
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D scalar <- ggml_new_i32(ctx, 42)
> ##D ggml_get_i32(scalar)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_new_i32", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_new_tensor")
> ### * ggml_new_tensor
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_new_tensor
> ### Title: Create Tensor with Arbitrary Dimensions
> ### Aliases: ggml_new_tensor
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor(ctx, GGML_TYPE_F32, 3, c(10, 20, 30))
> ##D ggml_nelements(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_new_tensor", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_new_tensor_1d")
> ### * ggml_new_tensor_1d
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_new_tensor_1d
> ### Title: Create 1D tensor
> ### Aliases: ggml_new_tensor_1d
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D tensor <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_nelements(tensor)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_new_tensor_1d", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_new_tensor_2d")
> ### * ggml_new_tensor_2d
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_new_tensor_2d
> ### Title: Create 2D tensor
> ### Aliases: ggml_new_tensor_2d
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D tensor <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 20)
> ##D ggml_nelements(tensor)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_new_tensor_2d", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_new_tensor_3d")
> ### * ggml_new_tensor_3d
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_new_tensor_3d
> ### Title: Create 3D Tensor
> ### Aliases: ggml_new_tensor_3d
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_3d(ctx, GGML_TYPE_F32, 10, 20, 30)
> ##D ggml_nelements(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_new_tensor_3d", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_new_tensor_4d")
> ### * ggml_new_tensor_4d
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_new_tensor_4d
> ### Title: Create 4D Tensor
> ### Aliases: ggml_new_tensor_4d
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_4d(ctx, GGML_TYPE_F32, 8, 8, 3, 2)
> ##D ggml_nelements(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_new_tensor_4d", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_out_prod")
> ### * ggml_out_prod
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_out_prod
> ### Title: Outer Product (Graph)
> ### Aliases: ggml_out_prod
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 3)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 4)
> ##D ggml_set_f32(a, c(1, 2, 3))
> ##D ggml_set_f32(b, c(1, 2, 3, 4))
> ##D c <- ggml_out_prod(ctx, a, b)  # Result: 3x4 matrix
> ##D graph <- ggml_build_forward_expand(ctx, c)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_out_prod", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_pad")
> ### * ggml_pad
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_pad
> ### Title: Pad Tensor with Zeros (Graph)
> ### Aliases: ggml_pad
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 5, 3)
> ##D ggml_set_f32(a, 1:15)
> ##D # Pad to 8x4
> ##D b <- ggml_pad(ctx, a, 3, 1)  # Add 3 zeros to dim0, 1 to dim1
> ##D graph <- ggml_build_forward_expand(ctx, b)
> ##D ggml_graph_compute(ctx, graph)
> ##D # Result shape: [8, 4]
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_pad", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_permute")
> ### * ggml_permute
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_permute
> ### Title: Permute Tensor Dimensions (Graph)
> ### Aliases: ggml_permute
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D # Create 4D tensor: (2, 3, 4, 5)
> ##D t <- ggml_new_tensor_4d(ctx, GGML_TYPE_F32, 2, 3, 4, 5)
> ##D # Swap axes 0 and 1: result shape (3, 2, 4, 5)
> ##D t_perm <- ggml_permute(ctx, t, 1, 0, 2, 3)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_permute", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_print_mem_status")
> ### * ggml_print_mem_status
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_print_mem_status
> ### Title: Print Context Memory Status
> ### Aliases: ggml_print_mem_status
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D ggml_print_mem_status(ctx)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_print_mem_status", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_print_objects")
> ### * ggml_print_objects
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_print_objects
> ### Title: Print Objects in Context
> ### Aliases: ggml_print_objects
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_print_objects(ctx)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_print_objects", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_quantize_chunk")
> ### * ggml_quantize_chunk
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_quantize_chunk
> ### Title: Quantize Data Chunk
> ### Aliases: ggml_quantize_chunk
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Quantize 256 floats to Q8_0 (block size 32)
> ##D data <- rnorm(256)
> ##D quantized <- ggml_quantize_chunk(GGML_TYPE_Q8_0, data, 1, 256)
> ##D ggml_quantize_free()  # Clean up
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_quantize_chunk", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_reglu")
> ### * ggml_reglu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_reglu
> ### Title: ReGLU (ReLU Gated Linear Unit) (Graph)
> ### Aliases: ggml_reglu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 8, 3)
> ##D ggml_set_f32(a, rnorm(24))
> ##D r <- ggml_reglu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)  # Shape: 4x3
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_reglu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_relu")
> ### * ggml_relu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_relu
> ### Title: ReLU Activation (Graph)
> ### Aliases: ggml_relu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D result <- ggml_relu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_relu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_reset")
> ### * ggml_reset
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_reset
> ### Title: Reset GGML Context
> ### Aliases: ggml_reset
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 100)
> ##D ggml_reset(ctx)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 200)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_reset", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_rope")
> ### * ggml_rope
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_rope
> ### Title: Rotary Position Embedding (Graph)
> ### Aliases: ggml_rope
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D # Query tensor: head_dim=8, n_head=4, seq_len=16, batch=1
> ##D q <- ggml_new_tensor_4d(ctx, GGML_TYPE_F32, 8, 4, 16, 1)
> ##D ggml_set_f32(q, rnorm(8 * 4 * 16))
> ##D # Position indices
> ##D pos <- ggml_new_tensor_1d(ctx, GGML_TYPE_I32, 16)
> ##D ggml_set_i32(pos, 0:15)
> ##D # Apply RoPE
> ##D q_rope <- ggml_rope(ctx, q, pos, 8, GGML_ROPE_TYPE_NORM)
> ##D graph <- ggml_build_forward_expand(ctx, q_rope)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_rope", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_rope_ext")
> ### * ggml_rope_ext
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_rope_ext
> ### Title: Extended RoPE with Frequency Scaling (Graph)
> ### Aliases: ggml_rope_ext
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D q <- ggml_new_tensor_4d(ctx, GGML_TYPE_F32, 64, 8, 32, 1)
> ##D ggml_set_f32(q, rnorm(64 * 8 * 32))
> ##D pos <- ggml_new_tensor_1d(ctx, GGML_TYPE_I32, 32)
> ##D ggml_set_i32(pos, 0:31)
> ##D # Standard RoPE with default freq_base
> ##D q_rope <- ggml_rope_ext(ctx, q, pos, NULL,
> ##D                         n_dims = 64, mode = 0L,
> ##D                         n_ctx_orig = 4096,
> ##D                         freq_base = 10000, freq_scale = 1.0,
> ##D                         ext_factor = 0.0, attn_factor = 1.0,
> ##D                         beta_fast = 32, beta_slow = 1)
> ##D graph <- ggml_build_forward_expand(ctx, q_rope)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_rope_ext", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_set_f32")
> ### * ggml_set_f32
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_set_f32
> ### Title: Set F32 data
> ### Aliases: ggml_set_f32
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D tensor <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(tensor, c(1, 2, 3, 4, 5))
> ##D ggml_get_f32(tensor)
> ##D ggml_free(ctx)
> ## End(Not run)
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(t, c(1, 2, 3, 4, 5))
> ##D ggml_get_f32(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_set_f32", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_set_i32")
> ### * ggml_set_i32
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_set_i32
> ### Title: Set I32 Data
> ### Aliases: ggml_set_i32
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D pos <- ggml_new_tensor_1d(ctx, GGML_TYPE_I32, 10)
> ##D ggml_set_i32(pos, 0:9)
> ##D ggml_get_i32(pos)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_set_i32", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_set_n_threads")
> ### * ggml_set_n_threads
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_set_n_threads
> ### Title: Set Number of Threads
> ### Aliases: ggml_set_n_threads
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Use 4 threads
> ##D ggml_set_n_threads(4)
> ##D 
> ##D # Use all available cores
> ##D ggml_set_n_threads(parallel::detectCores())
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_set_n_threads", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_set_no_alloc")
> ### * ggml_set_no_alloc
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_set_no_alloc
> ### Title: Set No Allocation Mode
> ### Aliases: ggml_set_no_alloc
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D ggml_set_no_alloc(ctx, TRUE)
> ##D ggml_get_no_alloc(ctx)
> ##D ggml_set_no_alloc(ctx, FALSE)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_set_no_alloc", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_set_zero")
> ### * ggml_set_zero
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_set_zero
> ### Title: Set Tensor to Zero
> ### Aliases: ggml_set_zero
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_set_f32(t, 1:10)
> ##D ggml_set_zero(t)
> ##D ggml_get_f32(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_set_zero", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_sgn")
> ### * ggml_sgn
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_sgn
> ### Title: Sign Function (Graph)
> ### Aliases: ggml_sgn
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -0.5, 0, 0.5, 2))
> ##D r <- ggml_sgn(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)  # c(-1, -1, 0, 1, 1)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_sgn", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_sigmoid")
> ### * ggml_sigmoid
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_sigmoid
> ### Title: Sigmoid Activation (Graph)
> ### Aliases: ggml_sigmoid
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D result <- ggml_sigmoid(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_sigmoid", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_silu")
> ### * ggml_silu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_silu
> ### Title: SiLU Activation (Graph)
> ### Aliases: ggml_silu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D result <- ggml_silu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_silu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_soft_max_ext")
> ### * ggml_soft_max_ext
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_soft_max_ext
> ### Title: Extended Softmax with Masking and Scaling (Graph)
> ### Aliases: ggml_soft_max_ext
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D scores <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 10)
> ##D ggml_set_f32(scores, rnorm(100))
> ##D attn <- ggml_soft_max_ext(ctx, scores, NULL, 1.0, max_bias = 0.0)
> ##D graph <- ggml_build_forward_expand(ctx, attn)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_soft_max_ext", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_softplus")
> ### * ggml_softplus
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_softplus
> ### Title: Softplus Activation (Graph)
> ### Aliases: ggml_softplus
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D r <- ggml_softplus(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_softplus", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_step")
> ### * ggml_step
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_step
> ### Title: Step Function (Graph)
> ### Aliases: ggml_step
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -0.5, 0, 0.5, 2))
> ##D r <- ggml_step(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)  # c(0, 0, 0, 1, 1)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_step", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_sub")
> ### * ggml_sub
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_sub
> ### Title: Element-wise Subtraction (Graph)
> ### Aliases: ggml_sub
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D b <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(5, 4, 3, 2, 1))
> ##D ggml_set_f32(b, c(1, 1, 1, 1, 1))
> ##D result <- ggml_sub(ctx, a, b)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_sub", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_swiglu")
> ### * ggml_swiglu
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_swiglu
> ### Title: SwiGLU (Swish/SiLU Gated Linear Unit) (Graph)
> ### Aliases: ggml_swiglu
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 8, 3)
> ##D ggml_set_f32(a, rnorm(24))
> ##D r <- ggml_swiglu(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, r)
> ##D ggml_graph_compute(ctx, graph)
> ##D result <- ggml_get_f32(r)  # Shape: 4x3
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_swiglu", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_tanh")
> ### * ggml_tanh
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_tanh
> ### Title: Tanh Activation (Graph)
> ### Aliases: ggml_tanh
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 5)
> ##D ggml_set_f32(a, c(-2, -1, 0, 1, 2))
> ##D result <- ggml_tanh(ctx, a)
> ##D graph <- ggml_build_forward_expand(ctx, result)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_get_f32(result)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_tanh", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_tensor_overhead")
> ### * ggml_tensor_overhead
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_tensor_overhead
> ### Title: Get Tensor Overhead
> ### Aliases: ggml_tensor_overhead
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_tensor_overhead()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_tensor_overhead", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_tensor_shape")
> ### * ggml_tensor_shape
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_tensor_shape
> ### Title: Get Tensor Shape
> ### Aliases: ggml_tensor_shape
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 10, 20)
> ##D ggml_tensor_shape(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_tensor_shape", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_tensor_type")
> ### * ggml_tensor_type
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_tensor_type
> ### Title: Get Tensor Type
> ### Aliases: ggml_tensor_type
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D t <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D ggml_tensor_type(t)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_tensor_type", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_test")
> ### * ggml_test
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_test
> ### Title: Test GGML
> ### Aliases: ggml_test
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_test()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_test", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_time_init")
> ### * ggml_time_init
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_time_init
> ### Title: Initialize GGML Timer
> ### Aliases: ggml_time_init
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_time_init()
> ##D start <- ggml_time_ms()
> ##D Sys.sleep(0.01)
> ##D elapsed <- ggml_time_ms() - start
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_time_init", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_time_ms")
> ### * ggml_time_ms
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_time_ms
> ### Title: Get Time in Milliseconds
> ### Aliases: ggml_time_ms
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_time_init()
> ##D start <- ggml_time_ms()
> ##D Sys.sleep(0.01)
> ##D elapsed <- ggml_time_ms() - start
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_time_ms", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_time_us")
> ### * ggml_time_us
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_time_us
> ### Title: Get Time in Microseconds
> ### Aliases: ggml_time_us
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_time_init()
> ##D start <- ggml_time_us()
> ##D Sys.sleep(0.001)
> ##D elapsed <- ggml_time_us() - start
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_time_us", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_top_k")
> ### * ggml_top_k
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_top_k
> ### Title: Top-K Indices (Graph)
> ### Aliases: ggml_top_k
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D # Logits from model output
> ##D logits <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 100)
> ##D ggml_set_f32(logits, rnorm(100))
> ##D # Get top 5 logits for sampling
> ##D top5 <- ggml_top_k(ctx, logits, 5)
> ##D graph <- ggml_build_forward_expand(ctx, top5)
> ##D ggml_graph_compute(ctx, graph)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_top_k", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_upscale")
> ### * ggml_upscale
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_upscale
> ### Title: Upscale Tensor (Graph)
> ### Aliases: ggml_upscale GGML_SCALE_MODE_NEAREST GGML_SCALE_MODE_BILINEAR
> ###   GGML_SCALE_MODE_BICUBIC
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D img <- ggml_new_tensor_2d(ctx, GGML_TYPE_F32, 8, 8)
> ##D ggml_set_f32(img, rnorm(64))
> ##D upscaled <- ggml_upscale(ctx, img, 2, GGML_SCALE_MODE_NEAREST)
> ##D graph <- ggml_build_forward_expand(ctx, upscaled)
> ##D ggml_graph_compute(ctx, graph)
> ##D # Result is 16x16
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_upscale", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_used_mem")
> ### * ggml_used_mem
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_used_mem
> ### Title: Get Used Memory
> ### Aliases: ggml_used_mem
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 100)
> ##D ggml_used_mem(ctx)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_used_mem", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_version")
> ### * ggml_version
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_version
> ### Title: Get GGML version
> ### Aliases: ggml_version
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ggml_version()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_version", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_view_1d")
> ### * ggml_view_1d
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_view_1d
> ### Title: 1D View with Byte Offset (Graph)
> ### Aliases: ggml_view_1d
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ctx <- ggml_init(16 * 1024 * 1024)
> ##D a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 100)
> ##D # View elements 10-19 (offset = 10 * 4 bytes = 40)
> ##D v <- ggml_view_1d(ctx, a, 10, 40)
> ##D ggml_free(ctx)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_view_1d", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_available")
> ### * ggml_vulkan_available
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_available
> ### Title: Check if Vulkan support is available
> ### Aliases: ggml_vulkan_available
> 
> ### ** Examples
> 
> ggml_vulkan_available()
[1] FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_available", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_backend_name")
> ### * ggml_vulkan_backend_name
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_backend_name
> ### Title: Get Vulkan backend name
> ### Aliases: ggml_vulkan_backend_name
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() > 0) {
> ##D   backend <- ggml_vulkan_init(0)
> ##D   print(ggml_vulkan_backend_name(backend))
> ##D   ggml_vulkan_free(backend)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_backend_name", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_device_count")
> ### * ggml_vulkan_device_count
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_device_count
> ### Title: Get number of Vulkan devices
> ### Aliases: ggml_vulkan_device_count
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available()) {
> ##D   ggml_vulkan_device_count()
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_device_count", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_device_description")
> ### * ggml_vulkan_device_description
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_device_description
> ### Title: Get Vulkan device description
> ### Aliases: ggml_vulkan_device_description
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() > 0) {
> ##D   ggml_vulkan_device_description(0)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_device_description", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_device_memory")
> ### * ggml_vulkan_device_memory
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_device_memory
> ### Title: Get Vulkan device memory
> ### Aliases: ggml_vulkan_device_memory
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() > 0) {
> ##D   mem <- ggml_vulkan_device_memory(0)
> ##D   cat("Free:", mem$free / 1e9, "GB\n")
> ##D   cat("Total:", mem$total / 1e9, "GB\n")
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_device_memory", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_free")
> ### * ggml_vulkan_free
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_free
> ### Title: Free Vulkan backend
> ### Aliases: ggml_vulkan_free
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() > 0) {
> ##D   backend <- ggml_vulkan_init(0)
> ##D   ggml_vulkan_free(backend)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_free", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_init")
> ### * ggml_vulkan_init
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_init
> ### Title: Initialize Vulkan backend
> ### Aliases: ggml_vulkan_init
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() > 0) {
> ##D   backend <- ggml_vulkan_init(0)
> ##D   print(ggml_vulkan_backend_name(backend))
> ##D   ggml_vulkan_free(backend)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_init", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_is_backend")
> ### * ggml_vulkan_is_backend
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_is_backend
> ### Title: Check if backend is Vulkan
> ### Aliases: ggml_vulkan_is_backend
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() > 0) {
> ##D   vk_backend <- ggml_vulkan_init(0)
> ##D   cpu_backend <- ggml_backend_cpu_init()
> ##D 
> ##D   ggml_vulkan_is_backend(vk_backend)  # TRUE
> ##D   ggml_vulkan_is_backend(cpu_backend) # FALSE
> ##D 
> ##D   ggml_vulkan_free(vk_backend)
> ##D   ggml_backend_free(cpu_backend)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_is_backend", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_list_devices")
> ### * ggml_vulkan_list_devices
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_list_devices
> ### Title: List all Vulkan devices
> ### Aliases: ggml_vulkan_list_devices
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (ggml_vulkan_available() && ggml_vulkan_device_count() > 0) {
> ##D   devices <- ggml_vulkan_list_devices()
> ##D   print(devices)
> ##D }
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_list_devices", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_vulkan_status")
> ### * ggml_vulkan_status
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_vulkan_status
> ### Title: Print Vulkan status
> ### Aliases: ggml_vulkan_status
> 
> ### ** Examples
> 
> ggml_vulkan_status()
Vulkan: NOT AVAILABLE
  To enable: reinstall with configure.args = "--with-vulkan"
  Requirements: Vulkan SDK, glslc compiler
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_vulkan_status", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ggml_with_temp_ctx")
> ### * ggml_with_temp_ctx
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ggml_with_temp_ctx
> ### Title: Execute with Temporary Context
> ### Aliases: ggml_with_temp_ctx
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Create tensors in temporary context
> ##D result <- ggml_with_temp_ctx(1024 * 1024, {
> ##D   a <- ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10)
> ##D   ggml_set_f32(a, 1:10)
> ##D   ggml_get_f32(a)
> ##D })
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ggml_with_temp_ctx", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.806 0.027 1.836 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
